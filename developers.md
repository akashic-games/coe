# COE フレームワークを利用した Akashic コンテンツの開発者向け文書

## はじめに

これは COE フレームワークを利用した Akashic コンテンツの開発者向け文書です。

## モデル

```
                                   Action
        Action    +------------+  (trusted)  +--------+
     +----------> | Controller | <---------- | system |
     |            +------------+             +--------+
     |                 |
     |   +-------------+   Command
     |   |             | (broadcast)
     |   v             v
  +--------+       +--------+
  |  View  |       |  View  |
  +--------+       +--------+
```

COE フレームワークには大きく分けて **Controller**, **View** と、それらの間でやり取りされる **Command**, **Action** が存在します。

### View

View は各クライアントおよびサーバ上に存在する **ビューインスタンス** です。
100人の参加者がいるマルチプレイゲームにおいては100人のそれぞれの手元に View が存在し、手元のゲーム画面を構築しています。
Akashic Engine においては各々のエンティティや、そのルートである `g.Scene` に相当します。

View は Controller からブロードキャストされた Command を受け取り、それに応じて状態や表示内容を更新します。
また、なにかしらのユーザインタラクションを契機として Controller に Action を送信することができます。

### Controller

Controller はある一つのゲームプレイ (以下プレイといいます) に一つだけ存在する **ゲーム実行状態管理インスタンス** です。
マルチプレイゲームにおいて参加者が2人であろうが1万人であろうが、常に一つだけしか存在しません。

Controller は主に View から送信された Action を受信したり、 View に対して Command をブロードキャストする機能を持っています。
各ユーザの手元で実行されている View は Controller に対して Action の送信、 Command の受信でしかデータをやり取りすることはできません。

### Action

View が Controller に対して送信するデータメッセージです。
View からは任意の型のデータが送信できます。
Controller はそのデータの送信者情報 (プレイヤーIDなど) が付与された形で参照できます。

### Command

Controller が View に対してブロードキャストするデータメッセージです。
Command は全ユーザに送信されるデータで、View はこのデータをもって自身の状態や描画内容を更新します。

過去にブロードキャストされた Command はすべて記録され、途中参加のユーザに対してもそれまで送信されたすべての Command が再現されます。

### 注意点

View と Controller の関係は、クライアントサーバモデルにおける「クライアント」と「サーバ」の関係とは独立である点にご留意ください。

## 通常の Akashic コンテンツとの違い

通常の Akashic コンテンツは **全ユーザの非ローカルな操作がすべて記録される** ように作られています。
(非ローカル・ローカルについての詳細は後述します。)

この特性は非常にわかりやすく明快ですが、複雑なアプリケーションを作成する上では問題がいくつかあります。

* クイズの答えのように本来隠したい内容が全ユーザに共有される
* ある特定のユーザの解答のみを表示したい
* 何も操作がない状態でも無駄な記録・通信が発生する

COE フレームワークは上記のケースを使いやすくラップしたライブラリになります。

それぞれのケースを順に解説していきます。

### 秘匿情報を含むメッセージの送信

Akashic において任意のメッセージイベントを送信したい場合 `g.Game#raiseEvent()` を呼び出します。

```javascript

// クイズ出題者
g.game.raiseEvent(new g.MessageEvent({
	answer: "答え"
}));

```

しかし、この方法ではすべてのユーザが内容を取得できてしまいます。

```javascript

// 全ユーザ
scene.message.add(message => {
	console.log(message.data) // { answer: "答え" }
	...
});

```

COE フレームワークを利用すると次のように書き換えることができます。

```javascript

// クイズ出題者が Action を送信
scene.send({
	answer: "答え"
});

```

送信した Action は Controller へと送信されます。

```javascript

let answer;

controller.actionReceived.add(action => {
	if (action.player.id === "出題者") {
		answer = action.data.answer;
	} else if (answer && action.data.answer === answer) {
		controller.broadcast({
			message: "正解しました！"
		});
	}
});

```

Controller は、あるプレイの全てのインスタンスのうち、ただ一箇所 (通常はサーバ上) でのみ動作するオブジェクトです。
ユーザの手元で actionReceived が fire されることがありません。

### 手動進行と自動進行

COE フレームワークが提供する `coe.Scene` は、原則 **手動進行モード** として生成されます。
(※自動進行として生成することもできます。)

手動進行はゲームの進行状態が自動ではなくコンテンツ側の契機によって進められるモードです。
対となるのが自動進行で、自動進行で作られたアプリケーションは1秒間に30回 (30fpsの場合) エンジンによって自動的にゲームが進行されています。

この進行のことを Akashic Engine では **ティックを消化する** と表現しています。

ティックの消化には重要な点があり、それはティックはサーバ上で生成され、逐次各クライアントに通知されていることです。
つまり **自動進行** で1万人のプレイヤーがマルチプレイに参加していたら、毎フレーム1万人へとティック情報が送信されることになります。
(何も操作がない場合でも「操作がない」というティック情報がサーバから毎フレーム送信されています。)

`Controller#broadcast()` による Command の送信はティックの生成に相当します。
したがって、COE フレームワークを用いることで通常の Akashic コンテンツ (自動進行) よりも大幅な通信回数の削減が期待できます。
(原則 `Controller#broadcast()` しない限りティックは生成されません。)

### プレイログの削減

前述したティック情報は [プレイログ](https://github.com/akashic-games/playlog) という形で永続的に保存されます。

ニコニコ生放送のタイムシフトでは、このプレイログ情報を基に放送当時の時間軸にしたがってゲームコンテンツが再現されます。

自動進行コンテンツは何も操作がなくてもティックは生成され続けるため、アンケートが1分間起動されていた場合は `1 * 60 * 30fps = 1800` のティック情報が記録されることになります。
(プレイログはティック以外の情報も含んでいますがここでは詳細を割愛しています。)

このプレイログから 10 秒目までを再現したい場合は 300 ティック目までを見ればよく、
すべてを再現したければ 1800 ティックをすべて見て、一フレームごとに一ティックを消化させていけばよいわけです。

この特性はコンテンツの再現性を高い精度で担保することが可能ですが、すべてのコンテンツにおいて適しているわけではありません。

例としてアンケートアプリケーションを自動進行コンテンツで作成することを考えてみます。
アンケートにおいては以下の2点のみが永続化されていればよく、その他の情報は本質的には必要ではありません。

* 設問と選択肢の表示およびその時間
* アンケート結果の表示およびその時間

このアンケートアプリケーションが **0秒後に設問と選択肢が表示され** 、 **30秒後 (900フレーム後) にアンケート結果が表示された** 際のプレイログ例を見てみます。

自動進行のプレイログ:

```
["アンケート表示", ...設問情報], [], [], [], ... , [], [], ["アンケート結果表示", ...結果情報], .... , [], [], []
```

手動進行のプレイログ:

```
["アンケート表示", ...設問情報, 0], ["アンケート結果表示", ...結果情報, 900]
```

手動進行は自動進行に比べて大幅にティック数が削減されていることがわかります。
(あくまで擬似的に表示しているため実際のデータ形式とは異なることに注意してください。)

ティック数の削減によりリプレイ速度の向上などが期待できます。
(ただし厳密なフレーム単位での時間再現が難しくなるため、アンケートのように「多少の時間再現の誤差が問題とならない」コンテンツでの利用が適しています。)

### 非ローカルとローカル

ティック生成におけるゲームの進行は全ユーザに影響を与えるグローバルな処理であり、これを Akashic では **非ローカル** と表現しています。
つまり Controller からの Command の送信は非ローカルの処理ということになります。
ローカルについての詳細は [Akashic のリファレンス](https://akashic-games.github.io/reference/akashic-engine-v2/classes/_lib_main_d_.g.scene.html#local) を参照してください。

一方で、各ユーザで異なる表示をさせたいケースもあります。

先程のアンケートの例で、アンケートを回答した際に「あなたは～を回答しました。」という文言を表示したいとします。
この内容は回答を選択したユーザに応じて変わるため、 **ローカル** として処理しなければなりません。

COE フレームワークが提供する `coe.Scene` は **ローカル** として生成されます。
これは `coe.Scene` で発生したいかなるイベント (エンティティクリックによる `g.PointDownEvent` の生成など) がローカルとなることを意味しています。

このように設問や結果の表示など **全ユーザに共有すべきもの** については Command でブロードキャストし、 **自分のみが対象になる描画状態の更新** は Command を利用することができません。

COE フレームワークが提供する `coe.Scene` を利用する限り、明示的に `Controller#broadcast()` を呼ばなければ Command は送信されません。

### Action の間引き

短い期間に大量の Action が送信されるとその一部がサーバ側で間引かれることがあります。
これはサーバおよびクライアントでの負荷対策のために設けられた制限であり、ゲームコンテンツ側で検知することはできません。
ゲームコンテンツは Action が間引かれることを常に想定しながら実装されていなければなりません。

ゲームの実行状態に関わる重要な Action が間引かれるのを防ぐために **優先度 (priority)** を指定することができます。

priority は `coe.Scene#send()` の第二引数で 0～2 の範囲で値を指定することができ、省略時は 0 とみなされます。
この値が大きいほど優先的に Controller へと送信されるため、間引かれてなならない Action は優先度を上げて送信する必要があります。

ただしこの仕様は **priority の高い Action が優先的に Controller へと送信される** という意味合いしか含まず、 **Controller へ必ず到達されるわけではない** という点に注意してください。
priority が 1 の Action が大量に送信された場合、priority が 0 のものと同様に間引かれる可能性があります。

### Role

COE フレームワークでは現在実行されているユーザの **役割 (Role)** を取得することができます。

```typescript
if (coe.hasRole("broadcaster")) {
	// 放送者のみで行いたい処理
}
```

| 値 | 説明 |
|----|-----|
| `broadcaster` | ユーザ生放送における放送者 |

現段階では、ユーザ生放送において番組の放送者であるかを表す `"broadcaster"` のみ判定することができます。

### Join されているかどうかの判定

対象のプレイヤーIDがすでに Join されているかを判定する関数 `coe.isJoinedPlayer()` もあります。

ユーザ生放送の場合、放送者のみ Join されることを利用して **対象の Action が放送者によって送信されたかどうか** を判定することができます。
(ただし Controller でのみ判定可能です。)

```typescript
controller.actionReceived.add(action => {
	if (coe.isJoinedPlayer(action.player.id)) {
		// 配信者の Action
	}
});
```
